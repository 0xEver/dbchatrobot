Telegram бот для получения статистики по видео с помощью запросов на естественном языке. Бот использует GigaChat (Text-to-SQL подход) для автоматической генерации SQL-запросов на основе сообщений пользователя и выполняет их в базе данных PostgreSQL.

## Зависимости и требования

- Docker и Docker Compose (проект полностью настроен для запуска в контейнерах)
- Telegram Bot Token (токен для бота)
- GigaChat Authorization Key (авторизационный ключ для GigaChat)

## Получение чувствительных данных и настройка

В проекте используется файл `.env` для хранения секретов. Шаблон для него предоставлен в файле `.env_example`, который **не содержит** реальных чувствительных данных.

Для настройки выполните следующие шаги:

1. **Создайте файл `.env`** на основе примера:
   
   ```shell
   cp .env_example .env
   ```

2. **Telegram Bot Token**:
   
   - Перейдите в Telegram и найдите бота [@BotFather](https://t.me/BotFather).
   - Создайте нового бота (команда `/newbot`) или выберите существующего (`/mybots`).
   - Полученный токен вставьте в файл `.env` в переменную `TELEGRAM_BOT_TOKEN`.

3. **GigaChat Authorization Key**:
   
   - Зарегистрируйтесь на портале [Сбер API для разработчиков](https://developers.sber.ru/).
   - Создайте проект GigaChat API.
   - Сгенерируйте и скопируйте *Авторизационные данные* (Client ID и Secret или готовый токен авторизации).
   - Вставьте ключ в файл `.env` в переменную `GIGACHAT_CREDENTIALS`. (По умолчанию переменная `GIGACHAT_SCOPE` установлена в `GIGACHAT_API_PERS`, если у вас корпоративный доступ — измените на `GIGACHAT_API_CORP`).

## Локальный запуск (Docker)

Проект настроен для полностью автоматического развертывания с помощью Docker Compose.

Выполните команду в корневой папке проекта:

```shell
docker compose up --build
```

Данная команда автоматически:

1. Поднимет базу данных PostgreSQL.
2. Соберет контейнер приложения с зависимостями.
3. Дождется готовности базы данных (проверка healthcheck).
4. Выполнит загрузку начальных данных из файла `videos.json` в базу.
5. Запустит Telegram-бота.

## Структура проекта

Проект организован по модульному принципу:

- **`docker-compose.yml`** & **`Dockerfile`**: Конфигурация для сборки и развертывания проекта в Docker.
- **`start.sh`**: Entrypoint-скрипт для Docker контейнера. Запускает сначала скрипт загрузки данных (`src/loader.py`), а затем бота (`src/bot.py`).
- **`videos.json`**: Файл с сырыми данными для первичной загрузки статистики.

### Исходный код (`src/`)

- **`bot.py`**: Точка входа для Telegram-бота (построен на фреймворке `aiogram`). Содержит обработчики сообщений, которые принимают текстовые запросы от пользователей и передают их в сервисный слой.
- **`service.py`**: Сервисный слой (`StatsService`), реализующий основную бизнес-логику бота. Координирует работу LLM и базы данных:
  - Принимает текст от пользователя.
  - Обращается к `GigaChatService` для генерации SQL-запроса.
  - Выполняет базовую проверку безопасности (запрос должен начинаться с `SELECT`).
  - Выполняет запрос к БД через `db.py` и возвращает результат пользователю.
- **`llm.py`**: Отвечает за взаимодействие с API GigaChat (`GigaChatService`). Здесь хранится системный промпт (System Prompt), который предоставляет GigaChat схему базы данных и правила написания SQL. Формирует payload и очищает ответ (например, убирая markdown-блоки кода перед возвратом чистого SQL).
- **`db.py`**: Модуль управления асинхронным пулом подключений (используется `asyncpg`). Включает функции инициализации БД (чтение `schema.sql`) и предоставления пула соединений.
- **`loader.py`**: Скрипт-загрузчик данных. Читает `videos.json` и с помощью эффективных массовых вставок (`executemany`) загружает или обновляет данные в таблицах `videos` и `video_snapshots`.
- **`schema.sql`**: SQL-скрипт с описанием структуры базы данных. Создает таблицы `videos` и `video_snapshots`.

## Как работают запросы в GigaChat и генерация SQL

Проект **не загружает** данные из БД в контекст LLM. Вместо этого он использует подход **Text-to-SQL**:

1. **Формирование промпта и описание схемы данных**: В `llm.py` жестко задан `system_prompt`, в котором модель наделяется ролью эксперта-аналитика PostgreSQL. Мы описываем структуру базы прямо в тексте (DDL-подобный формат с комментариями), указывая таблицы `videos` и `video_snapshots`, их столбцы и типы данных (например, `id (UUID)`, `views_count (INTEGER)`, `created_at (TIMESTAMPTZ)`).
   
   **Используемый промпт**:
   
   ```
   Ты — эксперт-аналитик баз данных PostgreSQL. Твоя задача — сгенерировать один единственный SQL-запрос для ответа на вопрос пользователя на естественном языке на основе предоставленной схемы базы данных.
   
   СХЕМА БАЗЫ ДАННЫХ:
   
   Таблица "videos" (Сводная статистика по каждому видео):
   - id (UUID): Идентификатор видео
   - creator_id (UUID): Идентификатор автора
   - video_created_at (TIMESTAMPTZ): Дата и время публикации видео
   - views_count (INTEGER): Общее количество просмотров
   - likes_count (INTEGER): Общее количество лайков
   - comments_count (INTEGER): Общее количество комментариев
   - reports_count (INTEGER): Общее количество жалоб
   - created_at (TIMESTAMPTZ): Время создания записи в базе
   - updated_at (TIMESTAMPTZ): Время последнего обновления записи
   
   Таблица "video_snapshots" (Ежечасные снимки статистики видео):
   - id (UUID): Идентификатор снимка (снэпшота)
   - video_id (UUID): Ссылка на videos.id
   - views_count (INTEGER): Количество просмотров на момент снимка
   - likes_count (INTEGER): Количество лайков на момент снимка
   - comments_count (INTEGER): Количество комментариев на момент снимка
   - reports_count (INTEGER): Количество жалоб на момент снимка
   - delta_views_count (INTEGER): Прирост просмотров с момента предыдущего снимка
   - delta_likes_count (INTEGER): Прирост лайков с момента предыдущего снимка
   - delta_comments_count (INTEGER): Прирост комментариев с момента предыдущего снимка
   - delta_reports_count (INTEGER): Прирост жалоб с момента предыдущего снимка
   - created_at (TIMESTAMPTZ): Время создания снимка (ежечасно)
   - updated_at (TIMESTAMPTZ): Время обновления записи
   
   ПРАВИЛА:
   1. Верни ТОЛЬКО SQL-запрос. Не включай форматирование markdown (например, ```sql), пояснения или любой другой текст.
   2. Запрос должен возвращать ОДНО ЧИСЛО (количество, сумму и т.д.).
   3. Используй синтаксис PostgreSQL.
   4. Для фильтрации дат по полям TIMESTAMPTZ используй приведение типов `::date`. Пример: `created_at::date = '2025-11-28'`.
   5. "Сколько видео" обычно означает `COUNT(*)`.
   6. "На сколько выросли просмотры" или "прирост просмотров" означает `SUM(delta_views_count)` из таблицы `video_snapshots`.
   7. "Сколько разных видео получили новые просмотры" означает `COUNT(DISTINCT video_id)` из таблицы `video_snapshots` где `delta_views_count > 0`.
   8. Будь внимателен с диапазонами дат. "с 1 по 5 ноября включительно" означает `date >= '2025-11-01' AND date <= '2025-11-05'`.
   9. Текущий год — 2025, если не указано иное.
   10. Если пользователь спрашивает про конкретный id автора (creator_id), используй его в конструкции WHERE.
   
   ПРИМЕРЫ:
   User: "Сколько всего видео есть в системе?"
   SQL: SELECT COUNT(*) FROM videos;
   
   User: "На сколько просмотров в сумме выросли все видео 28 ноября 2025?"
   SQL: SELECT SUM(delta_views_count) FROM video_snapshots WHERE created_at::date = '2025-11-28';
   
   User: "Сколько разных видео получали новые просмотры 27 ноября 2025?"
   SQL: SELECT COUNT(DISTINCT video_id) FROM video_snapshots WHERE created_at::date = '2025-11-27' AND delta_views_count > 0;
   
   ```
   
   *В промпт специально встроены строгие правила (например, приведение типов `::date` для дат) и примеры для точной настройки формата вывода.*

2. **Параметры генерации**: Для запросов установлена низкая температура (`temperature=0.1`), чтобы минимизировать галлюцинации LLM и гарантировать детерминированную генерацию SQL-кода без лишних пояснений.

3. **Очистка ответа**: Ответ модели пропускается через регулярные выражения для удаления Markdown (строк с ```sql). Результатом становится чистый SQL-запрос.

## Как строятся запросы к базе данных

1. Полученный от GigaChat SQL-запрос проверяется сервисом (`service.py`) на то, что это запрос на чтение (`SELECT`). Это базовая защита от SQL Injection на изменение структуры БД.
2. Запрос выполняется через пул `asyncpg` методом `fetchval()`, который ожидает и возвращает скалярное значение (одно число — результат агрегации `COUNT`, `SUM` и т.д.).
3. Если запрос успешен, число конвертируется в строку и отправляется пользователю. В случае любой ошибки (неверный SQL-синтаксис, сбои при генерации и т.д.) пользователю возвращается лаконичный ответ: `Ошибка`.
